// fractal.psh

cbuffer Constants : register(b0)
{
    float4 TimeAndResolution; // x=time, y=res.x, z=res.y, w=fractType
    float4 CameraPos; // xyz=pos, w=is3D (no usado en 2D)
    float4 CameraDirX; // xyz=right   (no usado)
    float4 CameraDirY; // xyz=up      (no usado)
    float4 CameraDirZ; // xyz=forward (no usado)

    float4 ZoomOffset; // x=zoom, y=off.x, z=off.y, w=off.z
    float4 FractalColor; // rgba tint
    float4 BackgroundColor; // rgba background

    float4 FractalC; // x=c.x, y=c.y (no usado aquí)
    int maxiter;
    float3 FractalParams1; // x=bailout, y=power(unused), z=escapeOffset(unused)
    float4 FractalParams2; // x=gamma, y/z/w extras

    float4 RenderFlags; // x=colorMode, y=shadingMode, z=useDE(unused), w=debugView(unused)
    float4 AnimationParams; // x=timeScale, y=speedY(unused), z=swirlSpeed, w=seed(unused)
};

struct PSInput
{
    float4 Pos : SV_POSITION;
    float2 UV : TEXCOORD;
};

float4 RenderMandelbrot2D(PSInput input)
{
    // 1) Tiempo y resolución
    float time        = TimeAndResolution.x * AnimationParams.x;  // timeScale
    float2 resolution = float2(TimeAndResolution.y, TimeAndResolution.z);

    // 2) UV en [-1,1] con corrección de aspecto
    float2 uv = input.UV * 2.0f - 1.0f;
    uv.x *= resolution.x / resolution.y;

    // 3) Zoom y offset
    float zoom    = ZoomOffset.x;      // default 1
    float2 offset = ZoomOffset.yz;     // default 0,0
    uv = uv / zoom + offset;

    // 4) Dinámica de c: deformar fractal, no rotar
    float2 c = uv; 
    float2 z = c;
    // AnimationParams.z = ampX, .w = ampY
    c.x += AnimationParams.z * sin(time);
    c.y += AnimationParams.w * cos(time);

    // 5) Parámetros de iteración
    int maxIter = maxiter; // ej. 100–1 000 000
    float bailout = FractalParams1.x;       // ej. 2.0
    float bb     = bailout * bailout;

    // 6) Iterar Mandelbrot
    int   i = 0;
    for (; i < maxIter; ++i)
    {
        z = float2(z.x*z.x - z.y*z.y, 2.0f*z.x*z.y) + c;
        if (dot(z, z) > bb)
            break;
    }

    // 7) Normalizar y gamma opcional (RenderFlags.x)
    float t = i / (float)maxIter;
    if (RenderFlags.x > 0.5f)
        t = pow(t, FractalParams2.x);

    // 8) Interpolar entre fondo y color del fractal
    float4 fg = FractalColor;    // default (1,1,1,1)
    float4 bg = BackgroundColor; // default (0,0,0,1)
    float4 col = lerp(bg, fg, t);

    // 9) Shading opcional (RenderFlags.y)
    if (RenderFlags.y > 0.5f)
        col.rgb *= t;

    return col;
}


float4 main(PSInput input) : SV_TARGET
{
    bool is3D = CameraPos.w > 0.5;
    int ft = (int) TimeAndResolution.w;
    if (is3D)
    {
        // TODO: RenderFractal3D(…)
        return float4(0, 0, 0, 1);
    }
    else
    {
        // Solo Mandelbrot por ahora (ft ignored)
        return RenderMandelbrot2D(input);
    }
}
